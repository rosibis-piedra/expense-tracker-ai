import { Expense, Category } from '@/types/expense';

export type ExportFormat = 'csv' | 'json' | 'pdf';

export interface ExportOptions {
  format: ExportFormat;
  filename: string;
  startDate?: string;
  endDate?: string;
  categories: Category[];
  includeAllCategories: boolean;
}

// CSV Export
export const exportToCSV = (expenses: Expense[], filename: string): void => {
  const headers = ['Date', 'Category', 'Amount', 'Description'];
  const rows = expenses.map(exp => [
    exp.date,
    exp.category,
    exp.amount.toFixed(2),
    exp.description.replace(/"/g, '""'), // Escape quotes
  ]);

  const csvContent = [
    headers.join(','),
    ...rows.map(row => row.map(cell => `"${cell}"`).join(',')),
  ].join('\n');

  downloadFile(csvContent, `${filename}.csv`, 'text/csv;charset=utf-8;');
};

// JSON Export
export const exportToJSON = (expenses: Expense[], filename: string): void => {
  const jsonData = {
    exportDate: new Date().toISOString(),
    totalExpenses: expenses.length,
    totalAmount: expenses.reduce((sum, exp) => sum + exp.amount, 0),
    expenses: expenses.map(exp => ({
      id: exp.id,
      date: exp.date,
      category: exp.category,
      amount: exp.amount,
      description: exp.description,
      createdAt: exp.createdAt,
    })),
  };

  const jsonContent = JSON.stringify(jsonData, null, 2);
  downloadFile(jsonContent, `${filename}.json`, 'application/json;charset=utf-8;');
};

// PDF Export (using HTML canvas approach)
export const exportToPDF = (expenses: Expense[], filename: string): void => {
  // Create a styled HTML document
  const totalAmount = expenses.reduce((sum, exp) => sum + exp.amount, 0);

  const htmlContent = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <title>Expense Report</title>
      <style>
        body { font-family: Arial, sans-serif; padding: 40px; }
        h1 { color: #0284c7; border-bottom: 3px solid #0284c7; padding-bottom: 10px; }
        .summary { background: #f0f9ff; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .summary-item { margin: 8px 0; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th { background: #0284c7; color: white; padding: 12px; text-align: left; }
        td { padding: 10px; border-bottom: 1px solid #e5e7eb; }
        tr:hover { background: #f9fafb; }
        .amount { text-align: right; font-weight: bold; }
        .footer { margin-top: 30px; text-align: center; color: #6b7280; font-size: 12px; }
      </style>
    </head>
    <body>
      <h1>Expense Report</h1>
      <div class="summary">
        <div class="summary-item"><strong>Generated:</strong> ${new Date().toLocaleDateString()}</div>
        <div class="summary-item"><strong>Total Expenses:</strong> ${expenses.length}</div>
        <div class="summary-item"><strong>Total Amount:</strong> $${totalAmount.toFixed(2)}</div>
      </div>
      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Category</th>
            <th>Description</th>
            <th>Amount</th>
          </tr>
        </thead>
        <tbody>
          ${expenses.map(exp => `
            <tr>
              <td>${new Date(exp.date).toLocaleDateString()}</td>
              <td>${exp.category}</td>
              <td>${exp.description}</td>
              <td class="amount">$${exp.amount.toFixed(2)}</td>
            </tr>
          `).join('')}
        </tbody>
      </table>
      <div class="footer">
        <p>Generated by Expense Tracker - ${new Date().toLocaleString()}</p>
      </div>
    </body>
    </html>
  `;

  downloadFile(htmlContent, `${filename}.html`, 'text/html;charset=utf-8;');
};

// Helper function to trigger download
const downloadFile = (content: string, filename: string, mimeType: string): void => {
  const blob = new Blob([content], { type: mimeType });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);

  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

// Filter expenses based on export options
export const filterExpensesForExport = (
  expenses: Expense[],
  options: Partial<ExportOptions>
): Expense[] => {
  let filtered = [...expenses];

  // Filter by date range
  if (options.startDate) {
    filtered = filtered.filter(exp => exp.date >= options.startDate!);
  }
  if (options.endDate) {
    filtered = filtered.filter(exp => exp.date <= options.endDate!);
  }

  // Filter by categories
  if (!options.includeAllCategories && options.categories && options.categories.length > 0) {
    filtered = filtered.filter(exp => options.categories!.includes(exp.category));
  }

  // Sort by date (newest first)
  filtered.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

  return filtered;
};
